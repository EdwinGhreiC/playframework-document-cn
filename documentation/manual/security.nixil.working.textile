h1. 安全性导引

The Play framework is designed with security in mind - but it is impossible to prevent developers using the framework to mess up and open holes. The guide describes the common security issues in web applications and how to avoid them in Play applications.

虽然Play在设计之初就考虑了安全性问题，但是任何人都无法阻止程序员们自毁长城。以下的向导将会涉及web应用常见的安全性问题，以及在Play中该如何避免。

h2. <a name="sessions">Sessions</a>

Often you need to keep information associated with a user, in particular the logged-in status. Without a session, the user would need to pass credentials with each request.

你经常会需要保存一些跟用户有关的信息，比如登录状态之类的。如果没有session，用户就得在每个请求当中都携带认证信息。

That’s what sessions are for: a set of cookies stored in the user’s browser that identify him or her to the web site, and provide other information your web application may choose to store there rather than in the data layer; for example the language.

所谓session就是，一组储存在用户浏览器的cookie中的数据，用于标识用户，很多时候还会根据应用的需要存储一些额外信息，比如用户的语言。

h3. 保密- 别把秘密公开

The session is a hash of key/values, signed but not encrypted. That means that as long as your secret is safe, it is not possible for a third-party to forge sessions.

session是一组键/值的哈希，经过数字签名但是并未加密。这意味着，只要你的签名是安全的，任何第三方都无法伪造session。

The secret is stored in @conf/application.conf@. It is very important to keep it private: do not commit it in a public repository, and when you install an application written by someone else change the secret key to your own. You can do that with the command @play secret@.

这个数字签名保存在@conf/application.conf@中. 一定要保证机密的私有性，绝对不要把它提交到公有代码库中。当你安装了一个有其他人构建的应用时，记得一定要修改原来的数字签名, 用这个命令@play secret@。		

h3. 不储存关键数据

However, since it is not encrypted, you should not store critical data in the session. It can be seen by looking at the user cookie, by sniffing the connection on a local network or over wifi.

尽管如上面所述，由于cookie是未加密的，你还是不应在session当中存储关键性数据。否则可能被通过查看cookie，或者检测局域网/wifi的方式暴露。

The session is stored in a cookie, and cookies are limited to 4 KB. In addition to this limit, only strings can be stored.

Play的session是存储在cookie中的，而cookie的大小被浏览器限制为4KB. 除了空间限制外, cookie中还仅能保存文本值。

h2. <a name="xss">跨站脚本攻击</a>

Cross-site scripting is one of the most common vulnerabilities in web applications. It consists of injecting malicious JavaScript into web pages using forms that your application provides.

跨站脚本攻击是web应用最大的弱点之一。实施方式使用应用提供的表单，注入恶意JavaScript脚本.

Let’s say you’re writing a blog, and anyone can add a comment. If you blindly include what commenters have written into your HTML page, you’re opening your site to attacks. It can be:
* Show a popup to your visitors
* Redirect your visitors to a site controlled by the attacker
* Steal information supposed to be visible only to the current user, and send it back to the attacker’s site

假设你在写blog，而任何其它人都可以添加评论，如果你闭上眼睛任凭评论者将任何内容提交到你的HTML页面中，你的站点就会被攻击。可能会导致:

* 你的blog的访客将会收到一个弹出窗，这可能只是恶搞一下
* 你的blog的访客会被重定向到一个在攻击者控制之下的站点
* 窃取到本应只有当前用户才能看到的信息，并将其发送到攻击者的站点。


Consequently it is very important to be protected from those attacks.
因此避开这些攻击是至关重要的

Play’s template engine automatically escapes strings. If you really need to insert unescaped HTML in your templates, you can do so using the "raw()":javaextensions#raw Java extension on the string. But if the string comes from a user input, you need to make sure it is sanitized first.

When sanitizing user inputs, always prefer whitelisting (only allow a list of safe tags) to blacklisting (forbid a list of unsafe tags and allow all the rest).

"More on cross-site scripting":http://en.wikipedia.org/wiki/Cross-site_scripting

h2. <a name="sql">SQL Injection</a>

SQL injection is an exploit consisting in using user input to execute a SQL query that was not intended by the developer. This can be used to destroy data, or to get access to data that shouldn’t be visible to the current user.

!http://imgs.xkcd.com/comics/exploits_of_a_mom.png!

When you are using high level "find" methods, you should be covered against SQL injection. When you build your own queries manually, you need to be careful not to concatenate strings with @+@ but use @?@ placeholders.

This is good:

bc. createQuery("SELECT * from Stuff WHERE type= ?1").setParameter(1, theType);

This is NOT:

bc. createQuery("SELECT * from Stuff WHERE type=" + theType;

h2. <a name="csrf">Cross-Site Request Forgery</a>

The CSRF attack can be really problematic in web applications:

bq. This attack method works by including malicious code or a link in a page that accesses a web application that the user is believed to have authenticated. If the session for that web application has not timed out, an attacker may execute unauthorized commands.

To prevent this attack, the first thing to do is to use GET and POST methods appropriately. That means that only the POST method should be used to change the application’s state.

For POST requests the only way to secure critical actions properly is to issue an authenticity token. Play now has a built-in helper to handle that:

* a @checkAuthenticity()@ method available in controllers, that checks for a valid authenticity token in the request parameters and sends a forbidden response if something is bad.
* @session.getAuthenticityToken()@ generates an authenticity token only valid for the current session.
* @#{authenticityToken /}@ creates a hidden input field that you can add to any form.

So for example:

bc. public static destroyMyAccount() {
    checkAuthenticity();
    …
}

Will only work when called from a form including a proper authenticity token:

bc. <form method="post" action="/account/destroy">
    #{authenticityToken /}
    <input type="submit" value="destroy my account">
</form>

For POST requests, Play’s "form tag":tags#form automatically generates the authenticity token:

bc. #{form @destroyMyAccount()}
    <input type="submit" value="destroy my account">
#{/form}

You can of course add the @checkAuthenticity()@ method call as a "before filter":controllers#before if you want to protect all actions of a hierarchy of controllers.

"More on cross-site request forgery":http://en.wikipedia.org/wiki/Cross-site_request_forgery

p(note). **Continuing the discussion**
 
Next: %(next)"Play modules":modules%.